<div>Waiting for DM</div>
<ol class="initiativeList"></ol>
<script id="template-initiativeListItem" type="text/html">
<li class="mob" data-id="" data-mobType="" data-initiative="" data-speed="">
    <span class="initiativeScore"></span>
    <span class="mobName"></span>
    <button name="position">@</button>
    <button name="react">&#x26A0;</button>
    <button name="toggleMob">x</button>
</li>
</script>
<script type="application/javascript">
window.initiativeContext = {};
(function socialScript() {
    var onReceiveMessage, onClose, bindInputEvents,
        addPlayer, removePlayer, addDM, removeDM, startNextTurn, getNext,
        _template, _listEl, _subscribers, _events, _orderIndex;

    _listEl = document.querySelector("#social .initiativeList");
    _subscribers = {};
    _events = [];
    _orderIndex = 1;

    _template = document.querySelector("#template-initiativeListItem").innerHTML;

    /**
     * Cleans up bound events.
     */
    onClose = function() {
        window.socket.removeEventListener("message", onReceiveMessage);
        _subscribers = {};
        
        for (i = 0; i < _events.length; i++) {
            _events[i]();
        }
        _events = [];
    };

    /**
     * Ensures click etc events will fire for each item in the list.
     * @param {HTMLElement} The list item with buttons to bind.
     */
     bindInputEvents = function(li) {
         var buttons, handler;
         buttons = li.querySelectorAll("button");
         handler = fireEvent.bind({}, li);
         for (i = 0; i < buttons.length; i++) {
             buttons[i].addEventListener("click", handler);
             _events.push(buttons[i].removeEventListener.bind(buttons[i], "click", handler));
         }
     };

     /**
      * Calls subscribing callbacks.
      * @param {HTMLElement} li parentNode of the clicked element.
      * @param {DOMElement} event that occured.
      */
     fireEvent = function(li, event) {
         var name, data, i;
         if (typeof event === "string") {
             name = event;
         } else {
            name = event.currentTarget.getAttribute("name");
         }

         if (_subscribers[name] && _subscribers[name].length) {
            data = {};
            data.id = li.getAttribute("data-id");
            data.size = li.getAttribute("data-size");
            data.mob_type = li.getAttribute("data-mobType");
            data.colour = li.style.color;
            data.character_name = li.querySelector(".mobName").innerHTML;
            data.initiative = parseInt(li.getAttribute("data-initiative"));
            data.potential = parseInt(li.getAttribute("data-potential"));

            data.order = parseInt(li.getAttribute("data-order"));
            data.speed = {
                walk : parseInt(li.getAttribute("data-speed"))
            };

            for (i = 0; i < _subscribers[name].length; i++) {
                _subscribers[name][i](data);
            }
         }
     };

    /**
     * Handles messages received through the web socket.
     * @param {object} event that occured.
     */
    onReceiveMessage = function(event) {
        var data, el;
        data = JSON.parse(event.data);
        if (data["player_add"]) {
            addPlayer(data["player_add"]);
        }
        if (data["player_update"]) {
            addPlayer(data["player_update"], true);
        }
        if (data["player_remove"]) {
            removePlayer(data["player_remove"]);
        }
        if (data["dm_add"]) {
            addDM(data["dm_add"]); 
        }
        if (data["dm_remove"]) {
            removeDM();
        }
        if (data["session_id"]) {
            refreshList();
        }
        if (data["turn_start"]) {
            startNextTurn(data["turn_start"]);
        }
        if (data["session_end"]) {
            // Kaboom
            window.location.reload();
        }
    };

    /**
     * Sets the name of the DM in the display.
     * @param {object} data describing dm.
     */
    addDM = function(data) {
        var el = document.querySelector("#social > div");
        el.innerHTML = "DM is " + data.player_name;
    };

    /**
     * Reverts the dm display if they leave.
     */
    removeDM = function(data) {
        var el = document.querySelector("#social > div");
        el.innerHTML = "Waiting for DM";
    };

    /**
     * Removes a mob from the li     st.
     * @param {object} data describes the mob.
     */
    removePlayer = function(data) {
        var li, id;
        id = isNaN(data.player_id) ? data.id : data.player_id;
        li = _listEl.querySelector("li[data-id='" + id + "']");
        if (!li) {
            return;
        }
        if (data.from_combat && document.body.hasAttribute("data-isDm")) {
            // DM will keep players in list unless forced.
            // But should still ignore them when calculating next player.
            if (li.hasAttribute("data-initiative")) {
                li.setAttribute("data-potential", li.getAttribute("data-initiative"));
                li.removeAttribute("data-initiative");
            }
        } else {
            li.parentElement.removeChild(li);
        }
    };

    /**
     * Removes all mobs from the list.
     */
    removeAll = function() {
        while (_listEl.firstChild) {
            _listEl.removeChild(_listEl.firstChild);
        }
        _orderIndex = 1;
    };

    /**
     * Adds a mob to the list, by correct sort order.
     * @param {object} data describing the player
     * @param {boolean} isUpdate true if updating a player already in the list.
     * @param {boolean} isTurn true if it's this players turn.
     */
    addPlayer = function(data, isUpdate, isTurn) {
        var list, li, otherLi, fragment,
            inserted, i, extant, init;
        if (!isNaN(data.player_id)) {
            data.id = data.player_id
        }

        // Don't add same player more than once.
        li = _listEl.querySelector("li[data-id='" + data.id + "']");
        if (!li) {
            // probably would be faster to manipulate the template than the element...
            fragment = document.createDocumentFragment();
            fragment.appendChild(document.createElement("span"));
            fragment.firstElementChild.insertAdjacentHTML("beforeend", _template);
            li = fragment.firstElementChild.firstElementChild;
        } else if (!isUpdate) {
            return;
        } else {
            inserted = true;
        }

        li.setAttribute("data-id", data.id);
        li.setAttribute("data-mobType", data.mob_type || (isNaN(data.player_id) ? "npc" : "pc"));

        if (data.speed) { li.setAttribute("data-speed", data.speed.walk); }
        if (data.colour) { li.style.color = "#" + data.colour; }
        if (data.size) { li.setAttribute("data-size", data.size); }
        if (data.character_name) { li.querySelector(".mobName").innerHTML = data.character_name; }
        if (isEqual(window.playerId, data.id)) {
            li.setAttribute("data-isMyPc", "isMyPc");
        } else {
            li.removeAttribute("data-isMyPc");
        }

        // Add mobs in initiative order.
        if (!isNaN(data.initiative)) {
            inserted = false;
            li.parentNode.removeChild(li);
            li.querySelector(".initiativeScore").innerHTML = data.initiative;
            li.setAttribute("data-initiative", data.initiative);
            if (!data.order) {
                data.order = _orderIndex;
                _orderIndex++;
            }
            li.setAttribute("data-order", data.order);

            extant = _listEl.querySelectorAll("li.mob");
            for (i = 0; i < extant.length; i++) {
                init = parseInt(extant[i].getAttribute("data-initiative"));
                if (data.initiative > init) {
                    _listEl.insertBefore(li, extant[i]);
                    inserted = true;
                    break;
                } else if (data.initiative === init) {
                    // If same initiative, use the order property.
                    init = extant[i].getAttribute("data-order");
                    if (data.order < init) {
                        _listEl.insertBefore(li, extant[i]);
                        inserted = true;
                        break;
                    }
                }
            }
        }

        // If initiative not set, just append to the end.
        if (!inserted) {
            _listEl.appendChild(li);
        }
        
        if (isTurn) {
            otherLi = _listEl.querySelector(".currentTurn");
            if (otherLi) {
                otherLi.classList.remove("currentTurn");
            }
            li.classList.add("currentTurn");
        }
        bindInputEvents(li);
    };

    /**
     * Clears the list of names and gets a fresh list from the server.
     */
    refreshList = function() {
        return sendHttpRequest("session/" + window.sessionId + "/players", "GET", null, { isPersistent : true })
        .then(function(result){
            var i, players;
            result = JSON.parse(result.responseText);
            if (!result || !result.players) {
                throw "No players";
            }

            removeAll();

            players = result.players;
            for (i = 0; i < players.length; i++) {
                switch (players[i].player_type) {
                    case "dm": addDM(players[i]); break;
                    case "player": addPlayer(players[i]); break;
                    default: break;
                }
            }
        })
        .catch(function(err) {
            console.error(JSON.stringify(err));
        });
    };
    
    /**
     * Sets the display for the next turn of combat.
     */
    startNextTurn = function(data) {
        var li = _listEl.querySelector(".currentTurn");
        if (li) {
            li.classList.remove("currentTurn");
        }
        li = _listEl.querySelector("[data-id='" + data.id + "']");
        li.classList.add("currentTurn");
        fireEvent(li, "turn_start");
    };
    
    /**
     * Returns the li of the next turn.
     * @returns {HTMLElement} the list of the mob who has the next turn.
     */
    getNext = function() {
        // TODO: 0HP mobs.
        var el;
        if(!(el = _listEl.querySelector(".currentTurn ~ [data-initiative]"))) {
            // Will select the first that actually has init.
            el = _listEl.querySelector("[data-initiative]");
        }
        return el;
    };

    if(window.sessionId) {
        refreshList();
    }

    window.socket.addEventListener("message", onReceiveMessage);
    window.initiativeContext.addMob = addPlayer;
    window.initiativeContext.removeMob = removePlayer;

    /**
     * Removes any NPCs from the list, but keeps players.
     */
    window.initiativeContext.clearNpcs = function() {
        var i, list;
        list = _listEl.querySelectorAll("[data-mobType='npc']");
        for (i = 0; i < list.length; i++) {
            removePlayer({
                id : list[i].getAttribute("data-id")
            });
        }
    };

    /**
     * Finds who has the next turn according to the initiative order.
     * @returns {string} id of the mob who is next.
     */
    window.initiativeContext.getNext = function() {
        var next;
        if (next = getNext()) {
            return next.getAttribute("data-id");
        }
        return null;
    };

    /**
     * Subscribes to an event triggered by some operation or interation on the list.
     * @param {string} event The name of the event.
     * @param {function} handler The callback.
     */
    window.initiativeContext.onListEvent = function(event, handler) {
        if (!_subscribers[event]) {
            _subscribers[event] = [];
        }

        _subscribers[event].push(handler);
    };

    /**
     * Removes a handler from the list of subscribers.
     * @param {string} event to unsubsribe from.
     * @param {function} handler to remove.
     */
    window.initiativeContext.offListEvent = function(event, handler) {
        var i;
        if (!_subscribers[event]) {
            return;
        }

        if((i = _subscribers[event].indexOf(handler)) >= 0) {
            _subscribers[event].splice(i, 1);
        }
    };

    /**
     * Reorders the list based on initiative.
     */
    window.initiativeContext.orderList = function() {
        var listItems, temp, i, ordered, comparator;
        listItems = _listEl.querySelectorAll("li.mob");
        // Convert node list in to array.
        temp = [];
        for (i = 0; i < listItems.length; i++) {
            temp.push(listItems[i]);
        }
        listItems = temp;

        ordered = [];
        while(listItems.length > 0) {
            if (!ordered.length) {
                ordered.push(listItems[0]);
            } else {
                comparator = parseInt(listItems[0].getAttribute("data-initiative"));
                i = 0;
                while(
                    i < ordered.length
                    && comparator <= parseInt(ordered[i].getAttribute("data-initiative"))
                ) {
                    // <= preferences earlier entries.
                    i++;
                }
                ordered.splice(i, 0, listItems[0]);
            }
            listItems.shift();
        }

        while(_listEl.firstElementChild) {
            _listEl.removeChild(_listEl.firstElementChild);
        }
        for(i = 0; i < ordered.length; i++) {
            _listEl.appendChild(ordered[i]);
        }
    };
})();

</script>

