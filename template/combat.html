<article id="turn">
    <h1 class="turnHeading"></h1>
    <table id="map" class="ctrl-combatMap">
    </table>
</article>
<script type="application/javascript">
loadExternalScript("public/combatMap.js");
</script>
<script id="template-combatCell" type="text/html">
<td class="ctrl-combatCell">
    <button class="terrain">&nbsp;</button>
</td>
</script>
<script id="template-movementOption" type="text/html">
    <input
        id="movementType-{type}"
        type="radio"
        name="movementType"
        value="{type}"
        data-base="{remaining}"
        data-remaining="{remaining}"
        data-used="0"
    />
    <label for="movementType-{type}">
        <h6>{text}</h6>
        <span name="remaining">{remaining}</span>
    </label>
</script>
<script id="template-controls" type="text/html">
    <div class="ctrl-speedOptions"></div>
    <div class="ctrl-column">
        <div class="ctrl-toggle">
            <input if="dashAction" type="checkbox" name="dashAction" />
            <label for="dashAction">DASH</label>
        </div>
        <div class="ctrl-toggle">
            <input id="dashBonus" type="checkbox" name="dashBonus" />
            <label for="dashBonus">BONUS</label>
        </div>
    </div>
    <button class="ctrl-thickButton" name="done">DONE</button>
</script>
<script id="template-dmControls" type="text/html">
    <button class="ctrl-flat" name="start">Start</button>
    <button class="ctrl-flat" name="clear">Clear</button>
    <button class="ctrl-flat" name="reset">Quit</button>
    <div class="ctrl-tabSet" id="dmControlTabs" data-tabs="4">
        <input type="radio" name="controlTab" id="turnControlsTab" />
        <label for="turnControlsTab">TURN</label>
        <fieldset id="turnOptions">
            <legend></legend>
            <div class="ctrl-speedOptions"></div>
            <div class="ctrl-column">
                <div class="ctrl-toggle">
                    <input id="dashAction" type="checkbox" name="dashAction" />
                    <label for="dashAction">DASH</label>
                </div>
                <div class="ctrl-toggle">
                    <input id="dashBonus" type="checkbox" name="dashBonus" />
                    <label for="dashBonus">BONUS</label>
                </div>
            </div>
            <button class="ctrl-thickButton" name="done">DONE</button>
        </fieldset>

        <input type="radio" name="controlTab" id="mapControlsTab" checked />
        <label for="mapControlsTab">MAP</label>
        <fieldset id="mapOptions">
            <legend></legend>
            <div class="ctrl-coordinate">
                <input id="mapWidth" type="number" name="mapWidth" value="12" placeholder="width" />
                <span>x</span>
                <input id="mapHeight" type="number" name="mapHeight" value="12" placeholder="height" />
            </div>
        </fieldset>

        <input type="radio" name="controlTab" id="mobControlsTab" />
        <label for="mobControlsTab">MOB</label>
        <fieldset id="mobOptions">
            <legend></legend>
            <div>
                <input class="ctrl-flat" type="text" id="npcName" name="npcName" placeholder="NAME" />
            </div>
            <div class="ctrl-labelledNumber">
                <label for="npcInitiative">INIT</label>
                <input type="number" id="npcInitiative" name="npcInitiative" placeholder="0" />
            </div>
            <label for="npcSize">SIZE</label>
            <select id="npcSize" name="npcSize"></select>
            <div>
                <div class="ctrl-labelledNumber">
                    <input type="number" id="npcSpeed" name="npcSpeed" placeholder="30" />
                    <label class="number" for="npcSpeed">WALK</label>
                </div>
                <div class="ctrl-labelledNumber">
                    <input type="number" id="npcSpeed-swim" name="npcSpeed-swim" placeholder="0" />
                    <label class="number" for="npcSpeed-swim">SWIM</label>
                </div>
                <div class="ctrl-labelledNumber">
                    <input type="number" id="npcSpeed-fly" name="npcSpeed-fly" placeholder="0" />
                    <label class="number" for="npcSpeed-fly">FLY</label>
                </div>
            </div>
            <button class="ctrl-flat" name="addNpc">ADD</button>
        </fieldset>

        <input type="radio" name="controlTab" id="terrainControlsTab" />
        <label for="terrainControlsTab">TURF</label>
        <fieldset id="terrainOptions">
            <legend></legend>
            <div class="ctrl-coordinate">
                <input type="number" id="terrainWidth" name="terrainWidth" value="1" />
                <span>x</span>
                <input type="number" id="terrainLength" name="terrainLength" value="1" />
            </div>
            <ul class="ctrl-colourOption" name="terrainTypes"></ul>
        </fieldset>
    </div>
</script>
<script id="template-terrainType" type="text/html">
    <li>
        <input type="radio" id="terrainType-{type}" name="terrainType" value="{type}" />
        <label class="{type}" for="terrainType-{type}"></label>
        <label for="terrainType-{type}">{text}</label>
    </li>
</script>
<script type="application/javascript">
(function combatScript() {
    var updateMap, triggerNextTurn, renderMenu, isInRange, getDistance, subtractMovement,
        onMessageReceived, onTurnStart, onMyTurnStart, onDashChange, onTerrainMouseOver, onTerrainClick,
        onPlayerMove, onMoveSelected,
        template, _menuEl;

    template = mainEl.querySelector("#template-combatCell").innerHTML;
    _menuEl = document.getElementById("controls");

    /**
     * Renders the map then adds all combatants to the initiative list.
     * @param {object} data data from a GET session/map endpoint.
     * @param {string} turnMobId id of the mob whose turn it is if any.
     */
    updateMap = function(data, turnMobId) {
        var k, i;
        pageContext.renderMap(data, template);
        window.initiativeContext.clearNpcs();
        for (k in data.mobs) {
            for (i = 0; i < data.mobs[k].length; i++) {
                initiativeContext.addMob(data.mobs[k][i], true, isEqual(data.mobs[k][i].id, turnMobId));
            }
        }
    };

    /**
     * Sets the controls for this stage of the app.
     */
    renderMenu = function() {
        var template, k;
        while(_menuEl.firstElementChild) {
            _menuEl.removeChild(_menuEl.firstElementChild);
        }

        if (document.body.hasAttribute("data-isDm")) {
            renderDMMenu();
        } else {
            template = document.getElementById("template-controls").innerHTML;

            _menuEl.insertAdjacentHTML("beforeend", template);
        }

        onEvent("[name='done']", "click", triggerNextTurn);
        onEvent("[name='dashAction']", "change", onDashChange);
        onEvent("[name='dashBonus']", "change", onDashChange);
    };

    /**
     * Sets up the map to allow movement during a turn.
     */
    onMoveSelected = function(data) {
        pageContext.removeMapEvents();
        pageContext.onMapEvent("td > .terrain", "mouseover", onTerrainMouseOver.bind({}, data));
        pageContext.onMapEvent("td > .terrain", "click", onTerrainClick.bind({}, data));
    };

    /**
     * If player chooses to user her/his action/bonus to dash, adjust the remaining speed.
     */
    onDashChange = function() {
        var el, base, max;
        el = _menuEl.querySelector("#movementType-walk");
        base = parseInt(el.getAttribute("data-base"));
        used = parseInt(el.getAttribute("data-used"));
        total = base;

        if (_menuEl.querySelector("[name='dashAction']:checked")) {
            total += base;
        }
        if (_menuEl.querySelector("[name='dashBonus']:checked")) {
            total += base;
        }

        total -= parseInt(el.getAttribute("data-used"));

        if (total < 0) {
            total = 0;
        }

        el.setAttribute("data-remaining", total);
        el.parentNode.querySelector("[for='" + el.id + "'] [name='remaining']").innerHTML = total;
    };

    /**
     * Sets the menu up for user at the start of a turn.
     * @param {object} data describes the mob about to take a turn.
     */
    resetMenu = function(data) {
        var template, temp, el, list, i;
        template = document.getElementById("template-movementOption").innerHTML;
        el = _menuEl.querySelector(".ctrl-speedOptions");
        while(el.firstElementChild) {
            el.removeChild(el.firstElementChild);
        }

        list = _menuEl.querySelectorAll(":checked")
        for (i = 0; i < list.length; i++) {
             list[i].checked = false;
        }

        // Add the speeds we have access to.
        for (k in pageContext.movementTypes) {
            if (!pageContext.movementTypes.hasOwnProperty(k)) {
                continue;
            }
            // We don't have this speed.
            if (!data.speed[k]) {
                continue;
            }

            temp = template.replace(/{type}/g, k)
                .replace(/{text}/g, pageContext.movementTypes[k].text)
                .replace(/{remaining}/g, data.speed[k]);
            el.insertAdjacentHTML("beforeend", temp);
        }
        // Auto select walk.
        el.querySelector("[name='movementType'][value='walk']").checked = true;
        onEvent("[name='movementType']", "click", onMoveSelected.bind({}, data));
    }

    /**
     * Determines who has the next turn and broadcasts to everyone.
     */
    triggerNextTurn = function() {
        var id;
        if (id = initiativeContext.getNext()) {
            sendHttpRequest("session/" + window.sessionId + "/turn/" + id, "PUT");
            pageContext.removeMapEvents();
        }
    };

    /**
     * Reset the UI when each new turn starts
     * @param {object} data the mob whose turn it is.
     */
    onTurnStart = function(data) {
        var heading, el;
        pageContext.removeMapEvents();
        if (data.mob_type === "npc" && document.body.hasAttribute("data-isDm")) {
            // DM's turn for NPCs
            onMyTurnStart(data);
        } else if (isEqual(data.id, window.playerId)) {
            // Player's turn.
            onMyTurnStart(data);
        } else {
            // Switch off for everyone else.
            document.body.removeAttribute("data-isMyTurn");

            // Switch off DM's TURN tab.
            if (el = _menuEl.querySelector("#turnControlsTab")) {
                el.checked = false;
                el.classList.add("hiddenTab");
                _menuEl.querySelector("#dmControlTabs").setAttribute("data-tabs", 3);
            }
        }
        window.pageContext.setTurn(data.id);
        heading = mainEl.querySelector(".turnHeading");
        heading.classList.remove("updated");
        heading.innerHTML = data.character_name + "'s Turn";

        setTimeout(function() {
            heading.classList.add("updated");
        }, 50);
    };
    window.initiativeContext.onListEvent("turn_start", onTurnStart);

    /**
     * Calculates whether the mob can reach the given point this turn.
     * @param {HTMLElement} current tile the mob is currently on.
     * @param {HTMLElement} candidate tile the mob tries to reach.
     * @param {object} speed object with mobs selected movement speed.
     * @returns {boolean} true is point can be reach.
     */
    isInRange = function(current, candidate, speed) {
        if (speed.remaining <= 0) {
            return false;
        }
        if (getDistance(
            parseInt(candidate.getAttribute("data-x")),
            parseInt(candidate.getAttribute("data-y")),
            parseInt(current.getAttribute("data-x")),
            parseInt(current.getAttribute("data-y"))
        ) > speed.remaining) {
            return false;
        }
        return true;
    };

    /**
     * Calculates the distance between two points.
     * TODO: Difficult terrain etc.
     * @param {number} x1
     * @param {number} y1
     * @param {number} x2
     * @param {number} y2
     * @returns {number} The distance.
     */
    getDistance = function(x1, y1, x2, y2) {
        // Pythagoras
        distance = Math.sqrt(Math.pow(Math.abs(x2 - x1), 2) + Math.pow(Math.abs(y2 - y1), 2));
        // Apply transformation and remove decimal.
        distance = Math.floor(distance * UNITS_PER_TILE);
        // Can't be less than 0
        return distance >= 0 ? distance : 0;
    };

    /**
     * Determines if a tile is within range and changes the colour if so.
     * @param {MouseEvent} event The event containing the element that was clicked.
     */
    onTerrainMouseOver = function(mob, event) {
        var loc, current, speedEl;

        pageContext.removeClass("reachable");
        pageContext.removeClass("unreachable");
        loc = pageContext.getMobWithId(mob.id);
        current = pageContext.getCell(loc.x, loc.y);

        speedEl = _menuEl.querySelector("[name='movementType']:checked");

        if (isInRange(current, event.currentTarget, {
            type: speedEl.value,
            remaining : speedEl.getAttribute("data-remaining")
        })) {
            event.currentTarget.classList.add("reachable");
        } else {
            event.currentTarget.classList.add("unreachable");
        }
    };

    /**
     * Selects a tile for movement on a click.
     * Moves mob to new location on a double click.
     * @param {object} mob The mob to move.
     * @param {MouseEvent} event click event containing element that was clicked.
     */
    onTerrainClick = function(mob, event) {
        var distance, loc;
        if (!event.currentTarget.classList.contains("selected")) {
            // Update which tile is selected.
            pageContext.removeClass("selected");
            event.currentTarget.classList.add("selected");
            // Set the colour (important for mobile).
            onTerrainMouseOver(mob, event);
        } else {
            speedEl = _menuEl.querySelector("[name='movementType']:checked");
            loc = pageContext.getMobWithId(mob.id);
            if (isInRange(
                pageContext.getCell(loc.x, loc.y),
                event.currentTarget,
                {
                    type: speedEl.value,
                    remaining : parseInt(speedEl.getAttribute("data-remaining"))
                }
            )) {
                distance = moveMob(mob, event.currentTarget);
                subtractMovement(distance, speedEl);
            }
        }
        event.preventDefault();
    };

    /**
     * Updates your remaining movement after any move.
     * @param {number} distance How far was moved.
     * @param {HTMLElement} el Element with movement/speed details.
     */
    subtractMovement = function(distance, el) {
        var remaining;
        el.setAttribute("data-used", parseInt(el.getAttribute("data-used")) + distance);
        remaining = parseInt(el.getAttribute("data-remaining")) - distance;
        remaining = remaining >= 0 ? remaining : 0;
        el.setAttribute("data-remaining", remaining);
        el.parentNode.querySelector("[for='"+ el.id + "'] [name='remaining']").innerHTML = remaining;
    };

    /**
     * Moves a mob to a new location
     * @param {object} mob The mob to move.
     * @param {HTMLElement} location The tile to move to.
     * @param {boolean} silent If true, don't notify other users.
     * @returns {number} The distance moved.
     */
    moveMob = function(mob, location, silent) {
        var x1, y1, x, y, distance;
        mob = pageContext.getMobWithId(mob.id) || mob;
        x1 = mob.x;
        y1 = mob.y;
        if (mob) {
            pageContext.removeMob(mob);
        }

        x = parseInt(location.getAttribute("data-x"));
        y = parseInt(location.getAttribute("data-y"));

        pageContext.setMob(x, y, mob);

        // Notify all of the move.
        if (!silent) {
            sendHttpRequest(
                "session/" + window.sessionId + "/player/" + mob.id + "/move",
                "PUT",
                { x : x, y: y }
            );
        }

        return getDistance(x1, y1, x, y);
    };

    /**
     * Sets up everything for the current player's turn.
     * @param {object} data Details of the mob whose turn it is.
     */
    onMyTurnStart = function(data) {
        var tab;
        document.body.setAttribute("data-isMyTurn", "isMyTurn");
        resetMenu(data);
        // DM has a tab menu that must be shown and hidden when moving through turns
        if (tab = _menuEl.querySelector("#turnControlsTab")) {
            tab.classList.remove("hiddenTab");
            _menuEl.querySelector("#dmControlTabs").setAttribute("data-tabs", 4);
            tab.checked = true;
        }
        onMoveSelected(data);
    };
    
    /**
     * Updates the map when a player_move event is received.
     */
    onPlayerMove = function(data) {
        var newLocation = pageContext.getCell(data.x, data.y);
        moveMob(data, newLocation, true);
    };

    /**
     * Handles messages received through the web socket.
     */
    onReceiveMessage = function(event) {
        var data;
        data = JSON.parse(event.data);
        if (data["map_update"]) {
            updateMap(data["map_update"]);
        }
        if (data["player_move"]) {
            onPlayerMove(data["player_move"]);
        }

        if (data["player_remove"]) {
            pageContext.removeMob(data["player_remove"]);
        }

        // ignored by dm
        if (!document.body.hasAttribute("data-isDm")) {
            if (data["combat_end"]) {
                replaceBody("ready");
            }
        }
    };
    onEvent(window.socket, "message", onReceiveMessage);

    runAsync([
        // Get the current state of the map.
        sendHttpRequest("session/" + window.sessionId + "/map", "GET"),
        // Get the current turn.
        sendHttpRequest("session/" + window.sessionId + "/turn", "GET")
    ])
    .then(function(response) {
        wait(function() {
            var data, turnId;
            if (pageContext.renderMap) {
                data = {
                    map :JSON.parse(response[0].responseText || null),
                    turn : JSON.parse(response[1].responseText || null)
                };
                if (data.map.width) {
                    updateMap(
                        data.map,
                        data.turn && data.turn.turn_start && data.turn.turn_start.id.toString()
                    );
                    if (document.body.hasAttribute("data-isDm")) {
                        triggerNextTurn();
                    }
                }
                renderMenu();
                return true;
            }
            return false;
        });
    })
    .catch(function() {
        debugger;
    });

    document.body.setAttribute("data-state", "combat");

    /******************************* DM FUNCTIONS ********************************/
    var i,
        clear, start, reset, renderDMMenu, addTerrain, addMob, relocateMob, removeMob, generateMap,
        onPositionClicked,
        controlsTemplate, mapCellTemplate;

    /**
     * Resets the map to a blank slate.
     */
    clear = function(isSilent) {
        var map;
        pageContext.removeMapEvents();
        map = document.getElementById("map");
        map.removeAttribute("data-width");
        map.removeAttribute("data-height");
        while(map.firstChild) {
            map.removeChild(map.firstChild);
        }
        if (!isSilent) {
            sendHttpRequest("session/" + window.sessionId + "/map", "DELETE");
            replaceBody("dm_console");
        }
    };

    /**
     * Uploads and broadcasts map, then takes you to the main screen.
     */
    start = function() {
        var requestBody;
        requestBody = pageContext.mapToJSON();
        sendHttpRequest("session/" + window.sessionId + "/map", "DELETE", requestBody)
        .then(function() {
            return replaceBody("play");
        })
        .catch(function(res) {
            if(res.status) {
                console.error(res.status, res.responseText);
            } else {
                console.error(JSON.stringify(res));
            }
        });
    };

    /**
     * Deletes the session and goes back to the lobby page.
     */
    reset = function() {
        if (window.sessionId) {
            sendHttpRequest("session/" + window.sessionId, "DELETE")
            .then(function(res) {
                replaceBody("home", document.documentElement);
            })
        .   catch(function(res) {
                console.error(res.status, res.responseText);
            });
        } else {
            replaceBody("home", document.documentElement);
        }
        document.body.removeAttribute("data-isDm");
        delete window.sessionId;
    };

    /**
     * Allows the DM to instantly move the mob from one location to another.
     */
    relocateMob = function(data, event) {
        var mob;
        mob = pageContext.getMobWithId(data.id);
        if (mob) {
            pageContext.removeMob(mob);
            mob = void 0;
        }
        if (!addMob(clone(data), event) && mob) {
            // Weren't able to move because of terrain etc restrictions,
            // so put back where it was.
            pageContext.setMob(mob.x, mob.y, mob);
        }
    };

    /**
     * Adds a new MOB to the map.
     * @param {object} data describing the mob.
     * @param {DOMEvent} event The click event describing where to add the terrain.
     */
    addMob = function(data, event) {
        var x, y, size, extant, mapSize,
            i, j, el, container, orig;

        orig = data;
        data = clone(data);
        // only use this ID the first time.
        delete orig.id

        if (!data.id) {
            data.id = (new Date()).valueOf().toString();
            delete data.order;
            initiativeContext.addMob(data);
        }

        x = parseInt(event.currentTarget.getAttribute("data-x"));
        y = parseInt(event.currentTarget.getAttribute("data-y"));

        size = pageContext.mobSizes[data.size];
        extant = pageContext.getMob(x, y);

        for (i = 0; i < (extant ? extant.length : 0); i++) {
            // "a creature cannot enter the same space of another unless they are two sizes smaller or larger.
            if ((size.rank - pageContext.mobSizes[extant[i].size].rank) <= 1) {
                return false;
            }
        }

        mapSize = pageContext.getSize();
        maxX = mapSize.width;
        maxY = mapSize.height;

        for (i = x; i < x + size.tiles && i <= maxX; i++) {
            for (j = y; j < y + size.tiles && j <= maxY; j++) {
                // Needs A LOT of design work on what to do with larger creatures & multiple 
                // creatures on a tile...
                pageContext.setMob(i, j, data);
            }
        }
        
        // Notify all
        // TODO: WHEN Merge with dmSetup.js, ensure that request is only made during play.
        sendHttpRequest(
            "session/" + window.sessionId + "/player/" + data.id + "/move",
            "PUT",
            {
                x : x, y: y,
                character_name : data.character_name,
                colour : data.colour 
            }
        );
        return true;
    };

    /**
     * Adds a terrain to the map.
     * @param {DOMEvent} event The click event describing where to add the terrain.
     */
    addTerrain = function(event) {
        var x, y, X, Y, width, height, type,
            el, maxX, maxY;

        x = parseInt(event.currentTarget.getAttribute("data-x"));
        y = parseInt(event.currentTarget.getAttribute("data-y"));
        width = parseInt(document.querySelector("[name='terrainWidth']").value);
        height = parseInt(document.querySelector("[name='terrainLength']").value);
        type = document.querySelector("[name='terrainType']:checked").value;

        mapSize = pageContext.getSize();
        maxX = mapSize.width;
        maxY = mapSize.height;

        for (X = x; X < (x + width) && X <= maxX; X++) {
            for(Y = y; Y < (y + height) && Y <= maxY; Y++) {
                pageContext.setTerrain(X, Y, type);
            }
        }
    };

    /**
     * Generates a grid based on the user's request.
     */
    generateMap = function() {
        var width, height;
        width = parseInt(document.querySelector("[name='mapWidth']").value);
        height = parseInt(document.querySelector("[name='mapHeight']").value);
        clear(true);
        pageContext.renderMap({
            width: width,
            height: height
        }, mapCellTemplate);
    };

    onPositionClicked = function(data) {
        pageContext.removeMapEvents();
        if (!data.initiative) {
            data.initiative = data.potential;
            initiativeContext.addMob(data);
        }
        pageContext.onMapEvent("td > button", "click", relocateMob.bind({}, data));
    };

    /**
     * Renders controls in the menu container.
     */
    renderDMMenu = function() {
        var menu, el, i, option, template;
        template = document.getElementById("template-dmControls").innerHTML;
        _menuEl.insertAdjacentHTML("beforeend", template);

        // NPC creature sizes.
        el = _menuEl.querySelector("#mobOptions [name='npcSize']");
        for (i in pageContext.mobSizes) {
            option = document.createElement("option");
            option.setAttribute("value", i);
            option.innerHTML = pageContext.mobSizes[i].text;
            option.selected = (i === "medium");
            el.appendChild(option);
        }

        el = _menuEl.querySelector("#terrainOptions > ul[name='terrainTypes']");
        // Terrain type radio buttons.
        for (i in pageContext.terrainTypes) {
            option = document.getElementById("template-terrainType").innerHTML;
            option = option.replace(/{type}/g, i)
                .replace(/{text}/g, pageContext.terrainTypes[i].text);
            el.insertAdjacentHTML("beforeend", option);
        }

        // When add npc is clicked, we can select a cell to add them to.
        onEvent("button[name='addNpc']", "click", function() {
            var name, init, size;
            name = document.querySelector("[name='npcName']").value;
            // Can't add NPC if missing info.
            if (!name) {
                return;
            }

            init = parseInt(document.querySelector("[name='npcInitiative']").value) || 0;

            data = {
                character_name : name,
                initiative : init,
                size : document.querySelector("[name='npcSize']").value,
                speed : {
                    walk : parseInt(document.querySelector("[name='npcSpeed']").value) || 30,
                    swim : parseInt(document.querySelector("[name='npcSpeed-swim']").value) || 0,
                    fly: parseInt(document.querySelector("[name='npcSpeed-fly']").value) || 0
                },
                id : (new Date()).valueOf().toString()
            };

            initiativeContext.addMob(data);

            pageContext.removeMapEvents();
            // the data that we bind the the map event
            pageContext.onMapEvent("td > button", "click", addMob.bind({}, data));
        });

        // When position/location button is clicked for a mob, we can select a cell.
        initiativeContext.onListEvent("position", onPositionClicked);

        // When in set up mode, deleting an NPC gets rid of it completely.
        // TODO When marging with dmSetup, don't broadcast until combat has started.
        initiativeContext.onListEvent("toggleMob", function(data) {
            pageContext.removeMapEvents();
            pageContext.removeMob(data);
            if (data.mob_type === "npc") {
                initiativeContext.removeMob(data);
            } else {
                onPositionClicked(data);
            }

            sendHttpRequest(
                "session/" + window.sessionId + "/player/" + data.id + "/remove",
                "PUT"
            );
        });
        
        // When terrain type is selected, we can add a terrain to a cell.
        onEvent("input[name='terrainType']", "change", function() {
            pageContext.removeMapEvents();
            pageContext.onMapEvent("td > button", "click", addTerrain);
        });

        onEvent("[name='mapWidth']", "change", generateMap);
        onEvent("[name='mapHeight']", "change", generateMap);

        onEvent("button[name='clear']", "click", clear.bind({}, false));

        onEvent("button[name='start']", "click", start);

        onEvent("button[name='reset']", "click", reset);
    };
    
})();
</script>
