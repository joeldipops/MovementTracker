<article id="turn">
    <table id="map" class="ctrl-combatMap">
    </table>
</article>
<script type="application/javascript">
loadExternalScript("public/combatMap.js");
</script>
<script id="template-combatCell" type="text/html">
<td class="ctrl-combatCell">
    <button class="terrain">&nbsp;</button>
</td>
</script>
<script id="template-movementOption" type="text/html">
    <input
        id="movementType-{type}"
        type="radio"
        name="movementType"
        value="{type}"
        data-base="{remaining}"
        data-remaining="{remaining}"
        data-used="0"
    />
    <label for="movementType-{type}">
        <h6>{text}</h6>
        <span name="remaining">{remaining}</span>
    </label>
</script>
<script id="template-controls" type="text/html">
    <div class="ctrl-speedOptions"></div>
    <div class="ctrl-column">
        <div class="ctrl-toggle">
            <input if="dashAction" type="checkbox" name="dashAction" />
            <label for="dashAction">DASH</label>
        </div>
        <div class="ctrl-toggle">
            <input id="dashBonus" type="checkbox" name="dashBonus" />
            <label for="dashBonus">BONUS</label>
        </div>
    </div>
    <button class="ctrl-thickButton" name="done">DONE</button>
</script>
<script id="template-dmControls" type="text/html">
    <button class="ctrl-flat" name="start">Start</button>
    <button class="ctrl-flat" name="clear">Clear</button>
    <button class="ctrl-flat" name="reset">Quit</button>
    <div class="ctrl-tabSet" id="dmControlTabs" data-tabs="3">
        <input type="radio" name="controlTab" id="turnControlsTab" />
        <label class="hidden" for="turnControlsTab">TURN</label>
        <fieldset id="turnOptions">
            <legend></legend>
            <div class="ctrl-speedOptions"></div>
            <div class="ctrl-column">
                <div class="ctrl-toggle">
                    <input id="dashAction" type="checkbox" name="dashAction" />
                    <label for="dashAction">DASH</label>
                </div>
                <div class="ctrl-toggle">
                    <input id="dashBonus" type="checkbox" name="dashBonus" />
                    <label for="dashBonus">BONUS</label>
                </div>
            </div>
            <button class="ctrl-thickButton" name="done">DONE</button>
        </fieldset>

        <input type="radio" name="controlTab" id="mapControlsTab" checked />
        <label for="mapControlsTab">MAP</label>
        <fieldset id="mapOptions">
            <legend></legend>
            <div class="ctrl-coordinate">
                <input id="mapWidth" type="number" name="mapWidth" value="12" placeholder="width" />
                <span>x</span>
                <input id="mapHeight" type="number" name="mapHeight" value="12" placeholder="height" />
            </div>
        </fieldset>

        <input type="radio" name="controlTab" id="mobControlsTab" />
        <label for="mobControlsTab">MOB</label>
        <fieldset id="mobOptions">
            <legend></legend>
            <div>
                <input class="ctrl-flat" type="text" id="npcName" name="npcName" placeholder="NAME" />
            </div>
            <div class="ctrl-labelledNumber">
                <label for="npcInitiative">INIT</label>
                <input type="number" id="npcInitiative" name="npcInitiative" placeholder="0" />
            </div>
            <label for="npcSize">SIZE</label>
            <select id="npcSize" name="npcSize"></select>
            <div>
                <div class="ctrl-labelledNumber">
                    <input type="number" id="npcSpeed-walk" name="npcSpeed-walk" placeholder="30" />
                    <label class="number" for="npcSpeed-walk">WALK</label>
                </div>
                <div class="ctrl-labelledNumber">
                    <input type="number" id="npcSpeed-swim" name="npcSpeed-swim" placeholder="15" />
                    <label class="number" for="npcSpeed-swim">SWIM</label>
                </div>
                <div class="ctrl-labelledNumber">
                    <input type="number" id="npcSpeed-climb" name="npcSpeed-climb" placeholder="15" />
                    <label class="number" for="npcSpeed-climb">CLIMB</label>
                </div>
                <div class="ctrl-labelledNumber">
                    <input type="number" id="npcSpeed-fly" name="npcSpeed-fly" placeholder="0" />
                    <label class="number" for="npcSpeed-fly">FLY</label>
                </div>
                <div class="ctrl-labelledNumber">
                    <input type="number" id="npcSpeed-burrow" name="npcSpeed-burrow" placeholder="0" />
                    <label class="number" for="npcSpeed-burrow">DIG</label>
                </div>
            </div>
            <button class="ctrl-flat" name="addNpc">ADD</button>
        </fieldset>

        <input type="radio" name="controlTab" id="terrainControlsTab" />
        <label for="terrainControlsTab">TURF</label>
        <fieldset id="terrainOptions">
            <legend></legend>
            <div class="ctrl-coordinate">
                <input type="number" id="terrainWidth" name="terrainWidth" value="1" />
                <span>x</span>
                <input type="number" id="terrainLength" name="terrainLength" value="1" />
            </div>
            <ul class="ctrl-colourOption" name="terrainTypes"></ul>
        </fieldset>
    </div>
</script>
<script id="template-terrainType" type="text/html">
    <li>
        <input type="radio" id="terrainType-{type}" name="terrainType" value="{type}" />
        <label class="{type}" for="terrainType-{type}"></label>
        <label for="terrainType-{type}">{text}</label>
    </li>
</script>
<script id="template-reactionAlert" type="text/html">
    <h1>{message}</h1>
</script>
<script type="application/javascript">
(function combatScript() {
    var updateMap, triggerNextTurn, renderMenu, resetMenu, attemptMove, getDistance, subtractMovement,
        onMessageReceived, onTurnStart, onMyTurnStart, onReactionUsed, onCombatStart, onPlayStart, onSetupStart,
        onClearClicked, onStartClicked, onResetClicked, onDashChange, onTerrainMouseOver, onTerrainClick, onPlayerMove,
        onMoveSelected, onReactClicked, onPositionClicked,
        renderDMMenu, addTerrain, addMob, relocateMob, removeMob, generateMap, toggleMob,
        _template, _reactTemplate, _menuEl;

    _reactTemplate = mainEl.querySelector("#template-reactionAlert").innerHTML
    _template = mainEl.querySelector("#template-combatCell").innerHTML;
    _menuEl = document.getElementById("controls");

    /**
     * Renders the map then adds all combatants to the initiative list.
     * @param {object} data data from a GET session/map endpoint.
     * @param {string} turnMobId id of the mob whose turn it is if any.
     */
    updateMap = function(data, turnMobId) {
        var k, i;
        pageContext.renderMap(data, _template);
        window.initiativeContext.clearNpcs();
        for (k in data.mobs) {
            for (i = 0; i < data.mobs[k].length; i++) {
                initiativeContext.addMob(data.mobs[k][i], true, isEqual(data.mobs[k][i].id, turnMobId));
            }
        }
    };

    /**
     * Sets the controls for this stage of the app.
     */
    renderMenu = function() {
        var template, k;
        while(_menuEl.firstElementChild) {
            _menuEl.removeChild(_menuEl.firstElementChild);
        }

        if (document.body.hasAttribute("data-isDm")) {
            renderDMMenu();
        } else {
            template = document.getElementById("template-controls").innerHTML;
            _menuEl.insertAdjacentHTML("beforeend", template);
        }

        onEvent("[name='done']", "click", triggerNextTurn);
        onEvent("[name='dashAction']", "change", onDashChange);
        onEvent("[name='dashBonus']", "change", onDashChange);
    };

    /**
     * Sets up the map to allow movement during a turn.
     */
    onMoveSelected = function(data) {
        pageContext.removeMapEvents();
        pageContext.onMapEvent("td > .terrain", "mouseover", onTerrainMouseOver.bind({}, data), "turn");
        pageContext.onMapEvent("td > .terrain", "click", onTerrainClick.bind({}, data), "turn");
    };

    /**
     * If player chooses to user her/his action/bonus to dash, adjust the remaining speed.
     */
    onDashChange = function() {
        var el, els, i, base, max,
            dashChecked, bonusChecked;
        els = _menuEl.querySelectorAll("[name='movementType']");
        dashChecked = !!_menuEl.querySelector("[name='dashAction']:checked");
        bonusChecked = !!_menuEl.querySelector("[name='dashBonus']:checked");
        for (i = 0; i < els.length; i++) {
            el = els[i];
            base = parseInt(el.getAttribute("data-base"));
            used = parseInt(el.getAttribute("data-used"));
            total = base;

            if (dashChecked) {
                total += base;
            }
            if (bonusChecked) {
                total += base;
            }

            total -= parseInt(el.getAttribute("data-used"));

            if (total < 0) {
                total = 0;
            }

            el.setAttribute("data-remaining", total);
            el.parentNode.querySelector("[for='" + el.id + "'] [name='remaining']").innerHTML = total;
        }
    };

    /**
     * Sets the menu up for user at the start of a turn.
     * @param {object} data describes the mob about to take a turn.
     */
    resetMenu = function(data) {
        var template, temp, el, list, i;
        template = document.getElementById("template-movementOption").innerHTML;
        el = _menuEl.querySelector(".ctrl-speedOptions");
        while(el.firstElementChild) {
            el.removeChild(el.firstElementChild);
        }

        list = _menuEl.querySelectorAll(":checked")
        for (i = 0; i < list.length; i++) {
             list[i].checked = false;
        }

        // Add the speeds we have access to.
        for (k in pageContext.movementTypes) {
            if (!pageContext.movementTypes.hasOwnProperty(k)) {
                continue;
            }
            // We don't have this speed.
            if (!data.speed[k]) {
                //data.speed[k] = (data.speed["walk"] * pageContext.movementTypes[k].factor) || 0;
                continue;
            }

            temp = template.replace(/{type}/g, k)
                .replace(/{text}/g, pageContext.movementTypes[k].text)
                .replace(/{remaining}/g, data.speed[k]);
            el.insertAdjacentHTML("beforeend", temp);
        }
        // Auto select walk.
        el.querySelector("[name='movementType'][value='walk']").checked = true;
        onEvent("[name='movementType']", "click", onMoveSelected.bind({}, data), "turn");
    }

    /**
     * Determines who has the next turn and broadcasts to everyone.
     * @returns {Promise} resolves when turn has been updated at the backend.
     */
    triggerNextTurn = function() {
        var id;
        if (id = initiativeContext.getNext()) {
            pageContext.removeMapEvents();
            return sendHttpRequest("session/" + window.sessionId + "/turn/" + id, "PUT");
        } else {
            return newPromise();
        }
    };

    /**
     * Set up for the start of combat.
     */
    onCombatStart = function() {
        var i, ids;
        if (document.body.hasAttribute("data-isDm")) {
            ids = initiativeContext.listNpcIds();
            for (i = 0; i < ids.length; i++) {
                initiativeContext.toggleReaction(ids[i], true);
            }
        } else {
            initiativeContext.toggleReaction(window.playerId, true);
        }
    };

    /**
     * Reset the UI when each new turn starts
     * @param {object} data the mob whose turn it is.
     */
    onTurnStart = function(data) {
        var message, el;
        offEvents("turn");
        pageContext.removeMapEvents();
        message = "<h1>" + data.character_name + "'s Turn</h1>";
        if (data.mob_type === "npc" && document.body.hasAttribute("data-isDm")) {
            // DM's turn for NPCs
            onMyTurnStart(data);
        } else if (isEqual(data.id, window.playerId)) {
            // Player's turn.
            onMyTurnStart(data);
            message = "<h1>Your Turn</h1>";
        } else {
            // Switch off for everyone else.
            document.body.removeAttribute("data-isMyTurn");

            // Switch off DM's TURN tab.
            if (el = _menuEl.querySelector("#turnControlsTab")) {
                el.checked = false;
                el.classList.add("hiddenTab");
                _menuEl.querySelector("#dmControlTabs").setAttribute("data-tabs", 3);
            }
        }
        window.pageContext.setTurn(data.id);
        showAlert(message, 1000);
    };
    window.initiativeContext.onListEvent("turn_start", onTurnStart);

    /**
     * Calculates whether the mob can reach the given point this turn, then moves them.
     * @param {HTMLElement} current tile the mob is currently on.
     * @param {HTMLElement} candidate tile the mob tries to reach.
     * @param {object} mob Specifiy a mob to move.  If empty will just simulate the move to check if it can be done.
     * @returns {boolean} true if point can be reached.
     */
    attemptMove = function(current, candidate, mob) {
        var distance, els, speeds, i, j, k, value, total, startDistance;
        els = _menuEl.querySelectorAll("[name='movementType']");
        speeds = {};
        for (i = 0; i < els.length; i++) {
            value = parseInt(els[i].getAttribute("data-remaining"));
            if (value) {
                speeds[els[i].getAttribute("value")] = value;
            }
        }
        // No movement left.
        if (!Object.keys(speeds).length) {
            return false;
        }

        distance = getDistance(
            parseInt(candidate.getAttribute("data-x")),
            parseInt(candidate.getAttribute("data-y")),
            parseInt(current.getAttribute("data-x")),
            parseInt(current.getAttribute("data-y"))
        );
        // Can't pass the impassable.
        if (distance["impassable"]) {
            return false;
        }
        total = 0;

        // For each type of terrain
        for (k in distance) {
            if (!distance.hasOwnProperty(k)) {
                continue;
            }
            // Use the best speed we have first (eg. swimming for water)
            for (i = 0; i < pageContext.terrainTypes[k].speeds.length; i++) {
                startDistance = distance[k];
                if (distance[k] <= 0) {
                    break;
                }
                value = (pageContext.terrainTypes[k].speeds[i] || []).split("|");
                if (!speeds[value[0]]) {
                    continue;
                }
                value[1] = value[1] ? parseFloat(value[1], 10) : 1;
                if ((distance[k] * value[1]) < speeds[value[0]]) {
                    // made the distance with speed to spare.
                    speeds[value[0]] -= distance[k] * value[1];
                    distance[k] = 0;
                } else if ((distance[k] * value[1]) > speeds[value[0]]) {
                    // used up all of this speed trying to make the distance.
                    distance[k] -= Math.floor(speeds[value[0]] / value[1]);
                    speeds[value[0]] = 0;
                } else {
                    // Used all of this speed, but made the distance.
                    distance[k] = 0;
                    speeds[value[0]] = 0;
                }

                // Adjust all speeds by distance already moved.
                for (j in speeds) {
                    if (!speeds.hasOwnProperty(j) || j === value[0]) {
                        continue;
                    }
                    speeds[j] -= (startDistance - distance[k]);
                    speeds[j] = speeds[j] >= 0 ? speeds[j] : 0;
                }

                if (distance[k] === 0) {
                    break;
                }
            }
            // If we couldn't complete the distance with all our speeds, then it's not in range.
            if (distance[k]) {
                return false;
            }
        }
        if (mob) {
            subtractMovement(speeds);
            moveMob(mob, candidate);
        }
        return true;
    };

    /**
     * Calculates the distance between two points.
     * @param {number} x1 current horizontal position.
     * @param {number} y1 current "vertical" position.
     * @param {number} x2 candidate horizontal position.
     * @param {number} y2 candidate "vertical" position
     * @returns {object} Distanced travelled through each type of terrain.
     */
    getDistance = function(x1, y1, x2, y2) {
        var distance, m, c, i, k, factor, visited,
            x, y, result, cell;

        result = {};

        // Vertical line
        if (x1 === x2) {
            if (y1 === y2) {
                return result;
            }
            for (
                y = ((y1 < y2) ? y1 : y2) + 1;
                y <= ((y1 < y2) ? y2 : y1);
                y++
            ) {
                cell = pageContext.getCell(x1, y);
                cell = cell.getAttribute("data-type");
                if (!result[cell]) {
                    result[cell] = 0;
                }
                result[cell] += UNITS_PER_TILE;
            }
            return result;
        }

        factor = UNITS_PER_TILE * 10;

        x1 *= factor;
        x2 *= factor;
        y1 *= factor;
        y2 *= factor;

        // Find the line between the two points,
        m = (y2 - y1)/(x2 - x1);
        c = y1 - (m * x1);

        visited = {};

        // Find proportion of terrains the line passes through.
        for (
            i = (x1 < x2 ? x1 : x2) + 1;
            i <= (x1 < x2 ? x2 : x1);
            i++
        ) {
            y = Math.floor((m * i + c) / factor);
            x = Math.floor(i / factor);

            //if (visited[x + "," + y]) {
            //    continue;
            //}
            //visited[x + "," + y] = true;

            cell = pageContext.getCell(x, y);
            cell = cell.getAttribute("data-type");
            if (!result[cell]) {
                result[cell] = 0;
            }
            //result[cell] += UNITS_PER_TILE;
            result[cell]++;
        }

        // Find the actual distance travelled with pythagoras.
        distance = (Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) / factor) * UNITS_PER_TILE;

        for (k in result) {
            if (!result.hasOwnProperty(k)) {
                continue;
            }
            result[k] = Math.round(distance * (result[k] / Math.abs(x2 - x1)));
        }
        return result;
    };

    /**
     * Determines if a tile is within range and changes the colour if so.
     * @param {MouseEvent} event The event containing the element that was clicked.
     */
    onTerrainMouseOver = function(mob, event) {
        var loc, current, speedEl;

        pageContext.removeClass("reachable");
        pageContext.removeClass("unreachable");
        loc = pageContext.getMobWithId(mob.id);
        current = pageContext.getCell(loc.x, loc.y);

        if (attemptMove(current, event.currentTarget)) {
            event.currentTarget.classList.add("reachable");
        } else {
            event.currentTarget.classList.add("unreachable");
        }
    };

    /**
     * Selects a tile for movement on a click.
     * Moves mob to new location on a double click.
     * @param {object} mob The mob to move.
     * @param {MouseEvent} event click event containing element that was clicked.
     */
    onTerrainClick = function(mob, event) {
        var distance, loc;
        if (!event.currentTarget.classList.contains("selected")) {
            // Update which tile is selected.
            pageContext.removeClass("selected");
            event.currentTarget.classList.add("selected");
            // Set the colour (important for mobile).
            onTerrainMouseOver(mob, event);
        } else {
            loc = pageContext.getMobWithId(mob.id);
            attemptMove(pageContext.getCell(loc.x, loc.y), event.currentTarget, mob);
        }
        event.preventDefault();
    };

    /**
     * Updates your remaining movement after any move.
     * @param {object} speeds How much of each speed is left.
     */
    subtractMovement = function(speeds) {
        var el, k;
        for (k in speeds) {
            el = _menuEl.querySelector("[name='movementType'][value='"+ k  +"']");
            el.setAttribute(
                "data-used",
                parseInt(el.getAttribute("data-used")) + (parseInt(el.getAttribute("data-remaining")) - speeds[k])
            );
            el.setAttribute("data-remaining", speeds[k]);
            el.parentNode.querySelector("[for='"+ el.id + "'] [name='remaining']").innerHTML = speeds[k];
        }
    };

    /**
     * Moves a mob to a new location
     * @param {object} mob The mob to move.
     * @param {HTMLElement} location The tile to move to.
     * @param {boolean} silent If true, don't notify other users.
     * @returns {number} The distance moved.
     */
    moveMob = function(mob, location, silent) {
        var x1, y1, x, y, distance;
        mob = pageContext.getMobWithId(mob.id) || mob;
        x1 = mob.x;
        y1 = mob.y;
        if (mob) {
            pageContext.removeMob(mob);
        }

        initiativeContext.addMob(arguments[0])

        x = parseInt(location.getAttribute("data-x"));
        y = parseInt(location.getAttribute("data-y"));

        pageContext.setMob(x, y, mob);

        // Notify all of the move.
        if (!silent) {
            sendHttpRequest(
                "session/" + window.sessionId + "/player/" + mob.id + "/move",
                "PUT",
                { x : x, y: y }
            );
        }

        return getDistance(x1, y1, x, y);
    };

    /**
     * Sets up everything for the current player's turn.
     * @param {object} data Details of the mob whose turn it is.
     */
    onMyTurnStart = function(data) {
        var tab;
        document.body.setAttribute("data-isMyTurn", "isMyTurn");
        resetMenu(data);
        // DM has a tab menu that must be shown and hidden when moving through turns
        if (tab = _menuEl.querySelector("#turnControlsTab")) {
            tab.classList.remove("hiddenTab");
            _menuEl.querySelector("#dmControlTabs").setAttribute("data-tabs", 4);
            tab.checked = true;
        }
        window.initiativeContext.toggleReaction(data.id, true);
        onMoveSelected(data);
    };
    
    /**
     * Updates the map when a player_move event is received.
     */
    onPlayerMove = function(data) {
        var newLocation = pageContext.getCell(data.x, data.y);
        moveMob(data, newLocation, true);
    };

    /**
     * Handles messages received through the web socket.
     */
    onReceiveMessage = function(event) {
        var data, fn;
        data = JSON.parse(event.data);
        if (data["map_update"]) {
            updateMap(data["map_update"]);
        }
        if (data["player_move"]) {
            onPlayerMove(data["player_move"]);
        }
        if (data["terrain_update"]) {
            fn = function(data) {
                var x, y, size;
                size = pageContext.getSize();
                for (x = data.left; x < (data.left + data.width) && x <= size.width; x++) {
                    for(y = data.top; y < (data.top + data.height) && y <= size.height; y++) {
                        pageContext.setTerrain(x, y, data.type);
                    }
                }
            };
            fn(data["terrain_update"]);
        }
        if (data["player_remove"]) {
            pageContext.removeMob(data["player_remove"]);
        }
        if (data["player_react"]) {
            onReactionUsed(data["player_react"]);
        }
        if (data["combat_start"]) {
            onCombatStart();
        }
        // ignored by dm
        if (!document.body.hasAttribute("data-isDm")) {
            if (data["combat_end"]) {
                replaceBody("ready");
            }
        }
    };

    /**
     * When the DM first hits this page, or clicks "Clear" put the menu in setup mode.
     */
    onSetupStart = function() {
        var el;
        document.body.setAttribute("data-state", "setup");
        if (el = _menuEl.querySelector("#dmControlTabs")) {
            el.setAttribute("data-tabs", 3);
            el = el.querySelector("[for='turnControlsTab']")
            el.classList.add("hidden");
        }
        wait(function() {
            if (pageContext.terrainTypes) {
                renderMenu();
                generateMap();
                onEvent(window.socket, "message", onReceiveMessage);
                return true;
            } else {
                return false;
            }
        });
    };

    /**
     * When ready to play, put the page in play mode if it's currently in setup mode.
     */
    onPlayStart = function() {
        document.body.setAttribute("data-state", "combat");
        onEvent(window.socket, "message", onReceiveMessage);
        runAsync([
            // Get the current state of the map.
            sendHttpRequest("session/" + window.sessionId + "/map", "GET"),
            // Get the current turn.
            sendHttpRequest("session/" + window.sessionId + "/turn", "GET")
        ])
        .then(function(response) {
            var el;
            wait(function() {
                var data, turnId;
                if (pageContext.renderMap) {
                    data = {
                        map :JSON.parse(response[0].responseText || null),
                        turn : JSON.parse(response[1].responseText || null)
                    };
                    if (data.map.width) {
                        updateMap(
                            data.map,
                            data.turn && data.turn.turn_start && data.turn.turn_start.id.toString()
                        );
                    }
                    renderMenu();
                    if (el = _menuEl.querySelector("#dmControlTabs")) {
                        el.setAttribute("data-tabs", 4);
                        el = el.querySelector("[for='turnControlsTab']")
                        el.classList.remove("hidden");
                    }
                    if (document.body.hasAttribute("data-isDM")) {
                        onCombatStart();
                    }
                    initiativeContext.onListEvent("react", onReactClicked);
                    return true;
                }
                return false;
            });
        })
        .catch(function() {
            debugger;
        });
    };

    /**
     * Reset page between setup and combat mode.
     */
    resetEvents = function() {
        closePage();
        initiativeContext.offListEvent("react", onReactClicked);
        initiativeContext.offListEvent("position", onPositionClicked);
        initiativeContext.offListEvent("toggleMob", toggleMob);
    };

    if (document.body.hasAttribute("data-isDM")) {
        onSetupStart();
    } else {
        onPlayStart();
    }

    /**
     * Resets the map to a blank slate.
     */
    onClearClicked = function(isSilent) {
        var map;
        pageContext.removeMapEvents();
        map = document.getElementById("map");
        map.removeAttribute("data-width");
        map.removeAttribute("data-height");
        while(map.firstChild) {
            map.removeChild(map.firstChild);
        }
        if (!isSilent) {
            sendHttpRequest("session/" + window.sessionId + "/map", "DELETE");
            onSetupStart();
        }
    };

    /**
     * Uploads and broadcasts map, then takes you to the main screen.
     */
    onStartClicked = function() {
        var requestBody;
        requestBody = pageContext.mapToJSON();
        initiativeContext.resetTurns();
        runAsync([
            triggerNextTurn(),
            sendHttpRequest("session/" + window.sessionId + "/map", "PUT", requestBody)
        ])
        .then(function() {
            resetEvents();
            onPlayStart();
        })
        .catch(function(res) {
            if(res.status) {
                console.error(res.status, res.responseText);
            } else {
                console.error(JSON.stringify(res));
            }
        });
    };

    /**
     * Deletes the session and goes back to the lobby page.
     */
    onResetClicked = function() {
        if (window.sessionId) {
            sendHttpRequest("session/" + window.sessionId, "DELETE")
            .then(function(res) {
                replaceBody("home", document.documentElement);
            })
        .   catch(function(res) {
                console.error(res.status, res.responseText);
            });
        } else {
            replaceBody("home", document.documentElement);
        }
        document.body.removeAttribute("data-isDm");
        delete window.sessionId;
    };

    /**
     * Allows the DM to instantly move the mob from one location to another.
     */
    relocateMob = function(data, event) {
        var mob;
        mob = pageContext.getMobWithId(data.id);
        if (mob) {
            pageContext.removeMob(mob);
            mob = void 0;
        }
        if (!addMob(clone(data), event) && mob) {
            // Weren't able to move because of terrain etc restrictions,
            // so put back where it was.
            pageContext.setMob(mob.x, mob.y, mob);
        }
    };

    /**
     * Adds a new MOB to the map.
     * @param {object} data describing the mob.
     * @param {DOMEvent} event The click event describing where to add the terrain.
     */
    addMob = function(data, event) {
        var x, y, size, extant, mapSize,
            i, j, el, container, orig;

        orig = data;
        data = clone(data);
        // only use this ID the first time.
        delete orig.id

        if (!data.id) {
            data.id = (new Date()).valueOf().toString();
            delete data.order;
            initiativeContext.addMob(data);
        }

        x = parseInt(event.currentTarget.getAttribute("data-x"));
        y = parseInt(event.currentTarget.getAttribute("data-y"));

        size = pageContext.mobSizes[data.size];
        extant = pageContext.getMob(x, y);

        for (i = 0; i < (extant ? extant.length : 0); i++) {
            // "a creature cannot enter the same space of another unless they are two sizes smaller or larger.
            if ((size.rank - pageContext.mobSizes[extant[i].size].rank) <= 1) {
                return false;
            }
        }

        mapSize = pageContext.getSize();
        maxX = mapSize.width;
        maxY = mapSize.height;

        for (i = x; i < x + size.tiles && i <= maxX; i++) {
            for (j = y; j < y + size.tiles && j <= maxY; j++) {
                // Needs A LOT of design work on what to do with larger creatures & multiple 
                // creatures on a tile...
                pageContext.setMob(i, j, data);
            }
        }
        
        // Notify all
        // TODO: WHEN Merge with dmSetup.js, ensure that request is only made during play.
        if (document.body.getAttribute("data-state") === "combat") {
            sendHttpRequest(
                "session/" + window.sessionId + "/player/" + data.id + "/move",
                "PUT",
                {
                    x : x, y: y,
                    character_name : data.character_name,
                    colour : data.colour
                }
            );
        }
        return true;
    };

    /**
     * Adds a terrain to the map.
     * @param {DOMEvent} event The click event describing where to add the terrain.
     */
    addTerrain = function(event) {
        var x, y, X, Y, width, height, type,
            el, maxX, maxY;

        x = parseInt(event.currentTarget.getAttribute("data-x"));
        y = parseInt(event.currentTarget.getAttribute("data-y"));
        width = parseInt(document.querySelector("[name='terrainWidth']").value);
        height = parseInt(document.querySelector("[name='terrainLength']").value);
        type = document.querySelector("[name='terrainType']:checked").value;

        mapSize = pageContext.getSize();
        maxX = mapSize.width;
        maxY = mapSize.height;

        for (X = x; X < (x + width) && X <= maxX; X++) {
            for(Y = y; Y < (y + height) && Y <= maxY; Y++) {
                pageContext.setTerrain(X, Y, type);
            }
        }

        sendHttpRequest(
            "session/" + window.sessionId + "/map/add",
            "PUT",
            {
                left: x,
                top : y,
                width: width,
                height: height,
                type: type
            }
        );
    };

    /**
     * Generates a grid based on the user's request.
     */
    generateMap = function() {
        var width, height;
        width = parseInt(document.querySelector("[name='mapWidth']").value);
        height = parseInt(document.querySelector("[name='mapHeight']").value);
        onClearClicked(true);
        pageContext.renderMap({
            width: width,
            height: height
        }, _template);
    };

    /**
     * Moves the in-context mob to the clicked location.
     */
    onPositionClicked = function(data) {
        pageContext.removeMapEvents();
        if (!data.initiative) {
            data.initiative = data.potential;
            initiativeContext.addMob(data);
        }
        pageContext.onMapEvent("td > button", "click", relocateMob.bind({}, data));
    };


    /**
     * Notifies all players that a reaction has been used.
     */
    onReactClicked = function(data) {
        sendHttpRequest(
            "session/" + window.sessionId + "/player/" + data.id + "/react",
            "POST"
        );
        initiativeContext.toggleReaction(data.id, false);
    };

    /**
     * Displays a message that a reaction was used.
     */
    onReactionUsed = function(data) {
        var mob, message;
        if (isEqual(data.player_id, window.playerId)) {
            message = "You React!";
        } else {
            mob = initiativeContext.getMobData(data.player_id);
            message = mob.character_name + " Reacts!";
        }
        showAlert(_reactTemplate.replace("{message}", message), 1000);
    };
    
    /**
     * Shows or hides an existing mob from the map.
     * @param {object} data Describes the mob.
     */
    toggleMob = function(data) {
        pageContext.removeMapEvents();
        pageContext.removeMob(data);
        if (data.mob_type === "npc") {
            initiativeContext.removeMob(data);
        } else {
            onPositionClicked(data);
        }

        if (document.body.getAttribute("data-state") === "combat") {
            sendHttpRequest(
                "session/" + window.sessionId + "/player/" + data.id + "/remove",
                "PUT"
            );
        }
    };

    /**
     * Renders controls in the menu container.
     */
    renderDMMenu = function() {
        var menu, el, i, option, template;

        template = document.getElementById("template-dmControls").innerHTML;
        _menuEl.insertAdjacentHTML("beforeend", template);

        // NPC creature sizes.
        el = _menuEl.querySelector("#mobOptions [name='npcSize']");
        for (i in pageContext.mobSizes) {
            option = document.createElement("option");
            option.setAttribute("value", i);
            option.innerHTML = pageContext.mobSizes[i].text;
            option.selected = (i === "medium");
            el.appendChild(option);
        }

        el = _menuEl.querySelector("#terrainOptions > ul[name='terrainTypes']");
        // Terrain type radio buttons.
        for (i in pageContext.terrainTypes) {
            option = document.getElementById("template-terrainType").innerHTML;
            option = option.replace(/{type}/g, i)
                .replace(/{text}/g, pageContext.terrainTypes[i].text);
            el.insertAdjacentHTML("beforeend", option);
        }

        // When add npc is clicked, we can select a cell to add them to.
        onEvent("button[name='addNpc']", "click", function() {
            var name, init, size;
            name = document.querySelector("[name='npcName']").value;
            // Can't add NPC if missing info.
            if (!name) {
                return;
            }

            init = parseInt(document.querySelector("[name='npcInitiative']").value) || 1;

            data = {
                character_name : name,
                initiative : init,
                size : document.querySelector("[name='npcSize']").value,
                speed : {
                    walk : parseInt(document.querySelector("[name='npcSpeed-walk']").value) || 30,
                    swim : parseInt(document.querySelector("[name='npcSpeed-swim']").value) || 0,
                    climb: parseInt(document.querySelector("[name='npcSpeed-climb']").value) || 0,
                    fly: parseInt(document.querySelector("[name='npcSpeed-fly']").value) || 0
                },
                id : (new Date()).valueOf().toString()
            };

            initiativeContext.addMob(data);

            pageContext.removeMapEvents();
            // the data that we bind the the map event
            pageContext.onMapEvent("td > button", "click", addMob.bind({}, data));
        });

        // When position/location button is clicked for a mob, we can select a cell.
        initiativeContext.onListEvent("position", onPositionClicked);

        // When in set up mode, deleting an NPC gets rid of it completely.
        initiativeContext.onListEvent("toggleMob", toggleMob);
        
        // When terrain type is selected, we can add a terrain to a cell.
        onEvent("input[name='terrainType']", "change", function() {
            pageContext.removeMapEvents();
            pageContext.onMapEvent("td > button", "click", addTerrain);
        });

        onEvent("[name='mapWidth']", "change", generateMap);
        onEvent("[name='mapHeight']", "change", generateMap);

        onEvent("button[name='clear']", "click", onClearClicked.bind({}, false));

        onEvent("button[name='start']", "click", onStartClicked);

        onEvent("button[name='reset']", "click", onResetClicked);
    };
    
})();
</script>
